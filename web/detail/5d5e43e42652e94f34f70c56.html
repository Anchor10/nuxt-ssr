<!doctype html>
<html data-n-head-ssr data-n-head="">
  <head data-n-head="">
    <title data-n-head="true">爱情说说大全_爱情说说心情语录_经典爱情语录大全</title><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" name="viewport" content="initial-scale=1,user-scalable=no,maximum-scale=1,width=device-width"><meta data-n-head="true" data-hid="description" name="description" content="学习各大经典爱情说说、爱情语录等相关说说心情短句语录大全，就到说说园网，实时更新最新说说大全，包含伤感/甜蜜爱情说说大全！搞笑、经典语录说说应有尽有！"><meta data-n-head="true" data-hid="keywords" name="keywords" content="爱情说说, 说说大全, 说说心情, 心情语录, 经典爱情语录, 爱情语录大全"><link data-n-head="true" rel="icon" type="image/x-icon" href="/favicon.ico"><link data-n-head="true" rel="stylesheet" href="https://at.alicdn.com/t/font_1220616_bnzancnfus8.css"><link rel="preload" href="/_nuxt/81c84c20b0d30a8dc841.js" as="script"><link rel="preload" href="/_nuxt/cdb6e682180795fd90bd.js" as="script"><link rel="preload" href="/_nuxt/84d1f3ceb9484e7730cb.css" as="style"><link rel="preload" href="/_nuxt/008d4d2df2a66aa082d1.js" as="script"><link rel="preload" href="/_nuxt/87619929db82a44b37e9.css" as="style"><link rel="preload" href="/_nuxt/bb19c2147f1efa363c7c.js" as="script"><link rel="preload" href="/_nuxt/7b82ad72e4a757ffbc9a.js" as="script"><link rel="stylesheet" href="/_nuxt/84d1f3ceb9484e7730cb.css"><link rel="stylesheet" href="/_nuxt/87619929db82a44b37e9.css">
    <script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?2f76408dd19e267f6a269cb4d8971bd3";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script>
  </head>
  <body data-n-head="">
    <div data-server-rendered="true" id="__nuxt"><!----><div id="__layout"><div><div class="header"><div class="banner"></div> <div class="top-box"><div class="position-change"><div class="topbar con-width"><div class="left-bar clear"><ul class="nav-list clear"><li class="nav-item current"><a href="/" class="nuxt-link-active"><i class="iconfont icon-shouye2"></i> 首页
                            </a></li> <li class="nav-item"><a href="/news"><i class="iconfont icon-JS"></i> 恋爱技巧
                            </a></li> <li class="nav-item"><a href="/about"><i class="iconfont icon-vuejs"></i> 撩妹套路
                            </a></li> <li class="nav-item"><a href="/categories"><i class="iconfont icon-nodejs"></i> 聊天技巧
                            </a></li> <li class="nav-item"><a href="/user"><i class="iconfont icon-mongodb"></i> 挽回爱情
                            </a></li> <li class="nav-item"><a href="/" class="nuxt-link-active"><i class="iconfont icon-44"></i> 视频
                            </a></li> <li class="nav-item"><a href="/" class="nuxt-link-active"><i class="iconfont icon-msg"></i> 留言板
                            </a></li></ul></div> <div class="right-bar clear"><div class="login-btn"><a href="/login">登录</a></div></div></div></div></div></div> <div class="detail main"><div class="content"><div class="container"><div class="article-top"><div class="article-title">【转】原生js事件绑定和事件委托</div> <div class="article-info"><span></span> <span></span></div></div> <div><p>最近常在移动端开发，由于不是大型站点，不需要使用vue等库，也不需要引用jquery和zepto等。</p><p><br></p><p>写得最多得就是各种元素选择器和事件绑定，操作下来也是有点烦人。这时候怀念起jquery的美好来了，但是仅为了这个引用这么大个库，实在时下不了手，思考了一下，直接在html构造函数上拓展支持了。</p><p><br></p><p>按照习惯来走，一般我们会喜欢在选择的元素上直接 on + 事件 ，加上相应的逻辑函数完成一个事件绑定的。</p><p><br></p><p>这里要说明一下，js的事件绑定是特殊的，不同于老旧版本的事件绑定</p><p><br></p><pre class="ql-syntax" spellcheck="false">element.onclick = function () {}
</pre><p><br></p><p>这种方式绑定的事件，后面有其他相同绑定事件，会覆盖前面的逻辑代码，因此我们会使用 addEventListener 实现绑定，按照绑定事件的顺序执行所有操作。</p><p><br></p><pre class="ql-syntax" spellcheck="false">element.addEventListener('click', function() {
  console.log(1)
}, false)

element.addEventListener('click', function() {
  console.log(2)
}, false)

>> 1
>> 2
</pre><p><br></p><p>再深一步思考一下，什么是 事件委托 ，意义是什么。</p><p><br></p><p>事件委托，实际是把目标元素的事件绑定到其他元素上，借助触发事件。举个例子，我需要做个div容器展示文章，容器有个按钮，需要点击放大字体。这里你可以考虑把事件绑定到按钮上，也可以绑定到div上，两者实现效果并无不同。</p><p><br></p><p>但是要记得一点，所有的元素查找和事件绑定都是需要消耗性能和内存的，而复杂页面上的操作区域可能多达数十上百，每一个都独立绑定事件，页面在低端设备上也会出现执行卡顿的情况，影响体验。此外，常见需求里是有未来事件绑定的，你无法为尚未存在的元素绑定事件。</p><p><br></p><p>原生js实现委托一般是从event属性中获取当前点击位置的元素，并对元素进行逻辑代码。因此，可以考虑将两者做到一起。</p><p><br></p><pre class="ql-syntax" spellcheck="false">/** 
 * 事件绑定和事件委托
 * 类似jQuery的on/off/one的用法
 * @author mo
 * @param eventName 事件名称
 * @param selector 委托的子元素，可以为空
 * @param callback 事件逻辑代码
 * @description 在选择的元素上直接用on/off/one就好了,同时存在自身绑定事件和委托事件的，如需解绑，要分别解绑，仅off选择元素的事件是不会解绑代理的事件的
 * @example
 *
 * var test = document.querySelector('.test')
 *
 * test.on('click', function () {
 *  // TODO 
 * })
 *
 * test.one('click', function () {
 *  // TODO 
 * })
 *
 * test.on('click', '.childElement', function () {
 *  // TODO 
 * })
 *
 * test.off('click')
 *
 * test.off('click', '.childElement')
 *
 */

var p_n_space = /(^\s*)|(\s*$)/g, // 前后空格正则
  bind_list = {} // 绑定事件列表

HTMLElement.prototype.on = function(eventName, selector, callback) {

  // 预处理参数
  if (!eventName || !selector) {
    console.log('Arguments is require!')
    return false
  } else {

    eventName = eventName.toLowerCase()

    if (typeof selector == 'function') {
      callback = selector
      selector = null
    }
  }

  // 事件绑定逻辑

  if (!bind_list.eventName) bind_list.eventName = []

  bind_list.eventName.push({
    selector: selector,
    fn: function(event) {

      var ev = event || window.event,
        target = ev.target || ev.srcElement,
        targets, sSets, i = j = 0

      if (!selector) {

        // 当前元素绑定
        callback.apply(this, [ev])

        if (this.once) {
          delete this.once
          this.off(eventName, callback)
        }

      } else {

        targets = selector.split(',')

        for (; i &lt; targets.length; i++) {

          // 删除前后空格
          targets[i] = targets[i].replace(p_n_space, '')

          // 遍历集合
          sSets = this.querySelectorAll(targets[i])

          // 如果集合为空则说明不存在这种委托元素，不做处理
          if (sSets.length) {
            // 关系拆分
            // targets[i] = targets[i].split(/\s+/g).reverse()

            // 事件委托
            for (var j = 0; j &lt; sSets.length; j++) {
              if (target === sSets[j]) {

                callback.apply(target, [ev])

                if (this.once) {
                  delete this.once
                  this.off(eventName, selector, callback)
                }

                break;
              }
            }

          } else {
            return false
          }

        }

      }
    }
  })

  // 所有事件，包括委托事件都绑定到目标元素本身
  if (this.addEventListener) {
    this.addEventListener(eventName, bind_list.eventName[bind_list.eventName.length - 1].fn, false);
  } else if (this.attachEvent) {
    this.attachEvent("on" + eventName, bind_list.eventName[bind_list.eventName.length - 1].fn);
  }

}

// 移除全部事件
HTMLElement.prototype.off = function(eventName, selector) {

  if (!selector) selector = null

  // 预处理参数
  if (!eventName) {
    console.log('Arguments is require!')
    return false
  } else {

    eventName = eventName.toLowerCase()

  }


  // 遍历已添加列表
  for (var k = 0; k &lt; bind_list.eventName.length; k++) {
    // 仅移除相关的事件，分目标元素和委托元素绑定的事件
    if (bind_list.eventName[k] && selector == bind_list.eventName[k].selector) {
      if (this.removeEventListener) {
        this.removeEventListener(eventName, bind_list.eventName[k].fn, false);
      } else if (this.detachEvent) {
        this.detachEvent("on" + eventName, bind_list.eventName[k].fn);
      }
    }

    // 移除
    bind_list.eventName[k] = null
  }


}

// 一次性事件
HTMLElement.prototype.one = function(eventName, selector, callback) {
  this.once = true
  this.on(eventName, selector, callback)
}
</pre><p><br></p><p>需要注意，匿名function，即使写得一模一样，但是实际也是两个不同的对象。而原生js解绑事件时是需要传入相同的函数对象的，因此要具名声明函数，为了方便管理，我全放在了一个统一变量中保存，不需要时指向于null，让浏览器回收内存。</p><p><br></p><p>此外，一次性事件的实现很简单，就是执行一次后解绑事件即可。</p><p><br></p><p>整理代码后，之后的绑定操作就不用干重复活咯~</p><p> ———————————————— </p><p>版权声明：本文为CSDN博主「我家有条大大狗」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。</p><p>原文链接：<a href="https://blog.csdn.net/rongliang_chen/article/details/82740381" target="_blank">https://blog.csdn.net/rongliang_chen/article/details/82740381</a></p></div></div></div></div> <div class="footer"><div class="container"><div>声明</div> <div class="el-divider el-divider--horizontal"></div> <div>copyright</div></div></div></div></div></div><script>window.__NUXT__=function(n,s,p){return{layout:"default",data:[{article:{_id:"5d5e43e42652e94f34f70c56",categories:[s,p],body:"<p>最近常在移动端开发，由于不是大型站点，不需要使用vue等库，也不需要引用jquery和zepto等。</p><p><br></p><p>写得最多得就是各种元素选择器和事件绑定，操作下来也是有点烦人。这时候怀念起jquery的美好来了，但是仅为了这个引用这么大个库，实在时下不了手，思考了一下，直接在html构造函数上拓展支持了。</p><p><br></p><p>按照习惯来走，一般我们会喜欢在选择的元素上直接 on + 事件 ，加上相应的逻辑函数完成一个事件绑定的。</p><p><br></p><p>这里要说明一下，js的事件绑定是特殊的，不同于老旧版本的事件绑定</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">element.onclick = function () {}\n</pre><p><br></p><p>这种方式绑定的事件，后面有其他相同绑定事件，会覆盖前面的逻辑代码，因此我们会使用 addEventListener 实现绑定，按照绑定事件的顺序执行所有操作。</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">element.addEventListener('click', function() {\n&nbsp;&nbsp;console.log(1)\n}, false)\n\nelement.addEventListener('click', function() {\n&nbsp;&nbsp;console.log(2)\n}, false)\n\n&gt;&gt; 1\n&gt;&gt; 2\n</pre><p><br></p><p>再深一步思考一下，什么是 事件委托 ，意义是什么。</p><p><br></p><p>事件委托，实际是把目标元素的事件绑定到其他元素上，借助触发事件。举个例子，我需要做个div容器展示文章，容器有个按钮，需要点击放大字体。这里你可以考虑把事件绑定到按钮上，也可以绑定到div上，两者实现效果并无不同。</p><p><br></p><p>但是要记得一点，所有的元素查找和事件绑定都是需要消耗性能和内存的，而复杂页面上的操作区域可能多达数十上百，每一个都独立绑定事件，页面在低端设备上也会出现执行卡顿的情况，影响体验。此外，常见需求里是有未来事件绑定的，你无法为尚未存在的元素绑定事件。</p><p><br></p><p>原生js实现委托一般是从event属性中获取当前点击位置的元素，并对元素进行逻辑代码。因此，可以考虑将两者做到一起。</p><p><br></p><pre class=\"ql-syntax\" spellcheck=\"false\">/**&nbsp;\n&nbsp;* 事件绑定和事件委托\n&nbsp;* 类似jQuery的on/off/one的用法\n&nbsp;* @author mo\n&nbsp;* @param eventName 事件名称\n&nbsp;* @param selector 委托的子元素，可以为空\n&nbsp;* @param callback 事件逻辑代码\n&nbsp;* @description 在选择的元素上直接用on/off/one就好了,同时存在自身绑定事件和委托事件的，如需解绑，要分别解绑，仅off选择元素的事件是不会解绑代理的事件的\n&nbsp;* @example\n&nbsp;*\n&nbsp;* var test = document.querySelector('.test')\n&nbsp;*\n&nbsp;* test.on('click', function () {\n&nbsp;*&nbsp;&nbsp;// TODO&nbsp;\n&nbsp;* })\n&nbsp;*\n&nbsp;* test.one('click', function () {\n&nbsp;*&nbsp;&nbsp;// TODO&nbsp;\n&nbsp;* })\n&nbsp;*\n&nbsp;* test.on('click', '.childElement', function () {\n&nbsp;*&nbsp;&nbsp;// TODO&nbsp;\n&nbsp;* })\n&nbsp;*\n&nbsp;* test.off('click')\n&nbsp;*\n&nbsp;* test.off('click', '.childElement')\n&nbsp;*\n&nbsp;*/\n\nvar p_n_space = /(^\\s*)|(\\s*$)/g, // 前后空格正则\n&nbsp;&nbsp;bind_list = {} // 绑定事件列表\n\nHTMLElement.prototype.on = function(eventName, selector, callback) {\n\n&nbsp;&nbsp;// 预处理参数\n&nbsp;&nbsp;if (!eventName || !selector) {\n&nbsp;&nbsp;&nbsp;&nbsp;console.log('Arguments is require!')\n&nbsp;&nbsp;&nbsp;&nbsp;return false\n&nbsp;&nbsp;} else {\n\n&nbsp;&nbsp;&nbsp;&nbsp;eventName = eventName.toLowerCase()\n\n&nbsp;&nbsp;&nbsp;&nbsp;if (typeof selector == 'function') {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback = selector\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;selector = null\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;}\n\n&nbsp;&nbsp;// 事件绑定逻辑\n\n&nbsp;&nbsp;if (!bind_list.eventName) bind_list.eventName = []\n\n&nbsp;&nbsp;bind_list.eventName.push({\n&nbsp;&nbsp;&nbsp;&nbsp;selector: selector,\n&nbsp;&nbsp;&nbsp;&nbsp;fn: function(event) {\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;var ev = event || window.event,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;target = ev.target || ev.srcElement,\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;targets, sSets, i = j = 0\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (!selector) {\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 当前元素绑定\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback.apply(this, [ev])\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (this.once) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete this.once\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.off(eventName, callback)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;targets = selector.split(',')\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (; i &lt; targets.length; i++) {\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 删除前后空格\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;targets[i] = targets[i].replace(p_n_space, '')\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 遍历集合\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sSets = this.querySelectorAll(targets[i])\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 如果集合为空则说明不存在这种委托元素，不做处理\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (sSets.length) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 关系拆分\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// targets[i] = targets[i].split(/\\s+/g).reverse()\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 事件委托\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for (var j = 0; j &lt; sSets.length; j++) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (target === sSets[j]) {\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;callback.apply(target, [ev])\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (this.once) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete this.once\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.off(eventName, selector, callback)\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return false\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;})\n\n&nbsp;&nbsp;// 所有事件，包括委托事件都绑定到目标元素本身\n&nbsp;&nbsp;if (this.addEventListener) {\n&nbsp;&nbsp;&nbsp;&nbsp;this.addEventListener(eventName, bind_list.eventName[bind_list.eventName.length - 1].fn, false);\n&nbsp;&nbsp;} else if (this.attachEvent) {\n&nbsp;&nbsp;&nbsp;&nbsp;this.attachEvent(\"on\" + eventName, bind_list.eventName[bind_list.eventName.length - 1].fn);\n&nbsp;&nbsp;}\n\n}\n\n// 移除全部事件\nHTMLElement.prototype.off = function(eventName, selector) {\n\n&nbsp;&nbsp;if (!selector) selector = null\n\n&nbsp;&nbsp;// 预处理参数\n&nbsp;&nbsp;if (!eventName) {\n&nbsp;&nbsp;&nbsp;&nbsp;console.log('Arguments is require!')\n&nbsp;&nbsp;&nbsp;&nbsp;return false\n&nbsp;&nbsp;} else {\n\n&nbsp;&nbsp;&nbsp;&nbsp;eventName = eventName.toLowerCase()\n\n&nbsp;&nbsp;}\n\n\n&nbsp;&nbsp;// 遍历已添加列表\n&nbsp;&nbsp;for (var k = 0; k &lt; bind_list.eventName.length; k++) {\n&nbsp;&nbsp;&nbsp;&nbsp;// 仅移除相关的事件，分目标元素和委托元素绑定的事件\n&nbsp;&nbsp;&nbsp;&nbsp;if (bind_list.eventName[k] &amp;&amp; selector == bind_list.eventName[k].selector) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if (this.removeEventListener) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.removeEventListener(eventName, bind_list.eventName[k].fn, false);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else if (this.detachEvent) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this.detachEvent(\"on\" + eventName, bind_list.eventName[k].fn);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;// 移除\n&nbsp;&nbsp;&nbsp;&nbsp;bind_list.eventName[k] = null\n&nbsp;&nbsp;}\n\n\n}\n\n// 一次性事件\nHTMLElement.prototype.one = function(eventName, selector, callback) {\n&nbsp;&nbsp;this.once = true\n&nbsp;&nbsp;this.on(eventName, selector, callback)\n}\n</pre><p><br></p><p>需要注意，匿名function，即使写得一模一样，但是实际也是两个不同的对象。而原生js解绑事件时是需要传入相同的函数对象的，因此要具名声明函数，为了方便管理，我全放在了一个统一变量中保存，不需要时指向于null，让浏览器回收内存。</p><p><br></p><p>此外，一次性事件的实现很简单，就是执行一次后解绑事件即可。</p><p><br></p><p>整理代码后，之后的绑定操作就不用干重复活咯~</p><p>&nbsp;————————————————&nbsp;</p><p>版权声明：本文为CSDN博主「我家有条大大狗」的原创文章，遵循CC 4.0 by-sa版权协议，转载请附上原文出处链接及本声明。</p><p>原文链接：<a href=\"https://blog.csdn.net/rongliang_chen/article/details/82740381\" target=\"_blank\">https://blog.csdn.net/rongliang_chen/article/details/82740381</a></p>",__v:0,title:"【转】原生js事件绑定和事件委托",banner:"http://localhost:3000/uploads/e7e676458866dd29df22493b8b267d4e",smallText:"最近常在移动端开发，由于不是大型站点，不需要使用vue等库，也不需要引用jquery和zepto等。",updatedAt:"2019-08-29T03:05:41.301Z",related:[{categories:["5d50c2c11cea5813a851f17c","5d50c2c41cea5813a851f17d",p],viewCount:0,_id:"5d50c33d1cea5813a851f182",title:"解析女生五大恋爱心理 这三点尤为明显",body:'<p><strong>解析女生五大恋爱心理是什么?</strong>想必很多男生都好奇女生恋爱时候的心理是怎么样的，今天小编帮大家整理了一下<strong>女生五大恋爱心理</strong>，发现以下三点最明显，一起跟小编来看看吧。</p><p class="ql-align-center"><img src="http://adminc.kantao.cn/storage/2019/08/28/nwKA2xRrEIKmIZHYq1t7G0KNQpUP2RcQx9dS9loE.png"></p><p><strong>　以自我为中心的心理</strong></p><p>其实有这种心态的女人，她们会要求自己的男人像只宠物一样围绕着自己转，听自己的话，只能按照她的吩咐去做事，完全可以不顾及对方的需要，不会顾及对方的需求、兴趣、爱好和价值。因而也是比较难得到异性的爱的，有这样心态的人，只有通过改变才可以具备恋爱成功的基本条件。</p><p class="ql-align-center"><img src="http://adminc.kantao.cn/storage/2019/08/28/QQwCfZCaykmPNid2mjCXdCB2dFr9zs6Lj7WkUq7T.png" alt="女生五大恋爱心理"></p><p><strong>太过于现实的心理</strong></p><p>由于现在社会的巨大压力和金钱的诱惑。造成了很多情侣在处对象的时候要求门当户对，这样可以避免掉婚后很多不必要的麻烦，但是太过于务实就会给人一种太过于追逐名利的感觉，铜臭味太浓，会让自己摸不到头脑，搞不清两个人在一起是因为钱还是因为人?最后发现爱情竟然就这么不复存在了，如果我们把爱情踏踏实实的放到我们的心里，粗茶淡饭一样也是可以生活的快快乐乐。</p><p class="ql-align-center"><img src="http://adminc.kantao.cn/storage/2019/08/28/myivJA693fH8vNdXCUMZtmaxNs9DTyk84dhoy258.png" alt="女生恋爱心理"></p><p><strong>口是心非</strong></p><p>男人一定要自己身边的女人什么时候会变的口是心非。这点显得格外的重要，很多时候都是因为这个而吵架的。然而女性通常是在自己有欲望的时候才会变得口是心非，自己非常的想要，但是又不好意思张口，所以很多时候当约女朋友去看电影的时候，男朋友这个时候去买票的话，女朋友说不用，那么男朋友不去了，等着女朋友买，这样电影是根本不可能看成的，其实女性的这种奇怪的心理，是一种自我保护的计策，当然，有时候也是女性真正的内心的展现。</p><p>上面就是小编帮大家介绍的有关于<strong>女生恋爱心理的介绍</strong>，希望可以帮到大家,更多精彩内容关注<strong>恋爱聊天话术网</strong>。</p>',__v:0,banner:"http://localhost:3000/uploads/32ffc1f36a9b5237056cef8e51799016",smallText:"解析女生五大恋爱心理是什么?想必很多男生都好奇女生恋爱时候的心理是怎么样的，今天小编帮大家整理了一下女生五大恋爱心理，发现以下三点最明显，一起跟小编来看看吧。",updatedAt:"2019-08-29T02:53:28.364Z"},{categories:[s],viewCount:0,_id:"5d5a418034fa4b4bc4f41aa6",body:'<p>曾经诱多相爱，分手的时候就会有多痛苦，<strong>挽回爱情最感人的话</strong>能够挽回想要远去的TA吗?不管有没有用，一定要试了才知道，用挽回爱情最感人的话用尽全力的去挽回所爱吧，等到人走远再想挽回也就来不及了。</p><p class="ql-align-center"><img src="http://adminc.kantao.cn/storage/2019/08/28/XDMlqZrFSlXygrPXcYL2N2rPaYLZoIRg03uE7irk.jpeg" alt="挽回爱情最感人的话 想你太累却不愿忘记你"></p><p>1、请你一定要比我幸福，才不枉费我狼狈退出，再苦也不说苦，爱不用抱歉来弥补，至少我能成全你的追逐。</p><p>2、让我慢慢忘记你像阳光蒸发朝露。干干净净的心情从此不再背负思念荆棘。记忆它属于生命谁能轻易抹去，我只能全部都藏匿。</p><p>3、如此美丽夜晚，孤独是一种遗憾。想念得不到的爱情，已成习惯。情歌让我虚度浪漫，最后还是曲终人散。</p><p>4、你知道吗?我想把你放下，因为我想你太苦，想你太累，能够把你放下该有多好，可是，我能吗?我会吗?</p><p>5、你知道我為何不让你联络我吗?可能我要借此次的不得以,让自己把你的思念及爱全部压抑到最底,让自己不再想你了吧!让你的一切都回到你的位置上吧!</p><p class="ql-align-center"><img src="http://adminc.kantao.cn/storage/2019/08/28/X3RcyDvjZgW2pH3Ks91ZefUAf2NoDWl48z6BkwGQ.jpeg" alt="挽回爱情最感人的话 想你太累却不愿忘记你"></p><p>6、你最心疼我把眼哭红，记得你曾说过，不让我委屈泪流，我是不是你最疼爱的人，你为什么不说话，当我需要你的时候，你却沉默不说。</p><p>7、任时光匆匆流去我只在乎你!所以我求求你，别让我离开你。除了你我不能感到一丝丝情意!</p><p>8、如果可以，希望自己能来一场意外，让自己得了失意症，好让自己不再想妳!不再為了过去的甜蜜而回忆，不再為了妳夜夜失眠…</p><p>9、如果秋天走了，我会在雪地里等你;如果世界走了，我会在天堂里爱你;如果你走了，我会在泪水中等你。</p><p>10、如果有爱不能长久，请告诉我这到底算什么缘分;如果有情不能相守，请告诉我谁是你最疼爱的人。</p><p>以上就是【挽回爱情最感人的话 想你太累却不愿忘记你】的全部内容，关注<a href="http://www.vitooo.com/" target="_blank">恋爱聊天话术网</a>获取更多感人的情话，感谢阅读!</p>',__v:0,title:"挽回爱情最感人的话 想你太累却不愿忘记你",banner:"http://localhost:3000/uploads/de160ad7423755df272e187a396f0cab",smallText:"曾经诱多相爱，分手的时候就会有多痛苦，挽回爱情最感人的话能够挽回想要远去的TA吗?不管有没有用，一定要试了才知道，用挽回爱情最感人的话用尽全力的去挽回所爱吧，等到人走远再想挽回也就来不及了。",updatedAt:"2019-08-29T03:04:42.547Z"}]}}],error:null,serverRendered:!0}}(0,"5d50c2b41cea5813a851f17a","5d50c2b71cea5813a851f17b")</script><script src="/_nuxt/81c84c20b0d30a8dc841.js" defer></script><script src="/_nuxt/7b82ad72e4a757ffbc9a.js" defer></script><script src="/_nuxt/cdb6e682180795fd90bd.js" defer></script><script src="/_nuxt/008d4d2df2a66aa082d1.js" defer></script><script src="/_nuxt/bb19c2147f1efa363c7c.js" defer></script>
  </body>
</html>